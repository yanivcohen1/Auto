#pragma once

template <class T>
class CProxy_IHttpMonEvents : public IConnectionPointImpl<T, &__uuidof( _IHttpMonEvents ), CComDynamicUnkArray>
{
	//Warning this class will  be regenerated by the wizard.
public:
	HRESULT Fire_OnRequest(LONG id, LONG containerId, BSTR url, BSTR headers, BSTR method, BYTE *data, LONG cb)
	{
		SAFEARRAYBOUND bounds = {cb, 0};

		VARIANT pBytes;
		VariantInit(&pBytes);
		pBytes.vt = VT_ARRAY | VT_UI1 | VT_BYREF;

		SAFEARRAY* psaByte = NULL; 
		BYTE *strNames;
		psaByte = SafeArrayCreate(VT_UI1, 1, &bounds);

		SafeArrayAccessData(psaByte, (void**)&strNames);

		for(long i = 0; i < cb; i++)
		{
			strNames[i] = data[i];
		}

		SafeArrayUnaccessData(psaByte);
		pBytes.pparray = &psaByte;

		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();
		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[6];
				avarParams[5] = id;
				avarParams[5].vt = VT_I4;
				avarParams[4] = containerId;
				avarParams[4].vt = VT_I4;
				avarParams[3] = url;
				avarParams[3].vt = VT_BSTR;
				avarParams[2] = headers;
				avarParams[2].vt = VT_BSTR;
				avarParams[1] = method;
				avarParams[1].vt = VT_BSTR;
				avarParams[0] = pBytes;
				DISPPARAMS params = { avarParams, NULL, 6, 0 };
				hr = pConnection->Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		SafeArrayDestroy(psaByte);
		return hr;
	}

	HRESULT Fire_OnResponse(LONG id, LONG containerId, BSTR url, LONG responseCode, BSTR responseHeaders)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[5];
				avarParams[4] = id;
				avarParams[4].vt = VT_I4;
				avarParams[3] = containerId;
				avarParams[3].vt = VT_I4;
				avarParams[2] = url;
				avarParams[2].vt = VT_BSTR;
				avarParams[1] = responseCode;
				avarParams[1].vt = VT_I4;
				avarParams[0] = responseHeaders;
				avarParams[0].vt = VT_BSTR;
				DISPPARAMS params = { avarParams, NULL, 5, 0 };
				hr = pConnection->Invoke(2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}

	HRESULT Fire_OnRedirect(LONG id, LONG containerId, LONG redirectedId, BSTR url, BSTR redirectedUrl, BSTR responseHeaders, BSTR requestHeaders)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[7];
				avarParams[6] = id;
				avarParams[6].vt = VT_I4;
				avarParams[5] = containerId;
				avarParams[5].vt = VT_I4;
				avarParams[4] = redirectedId;
				avarParams[4].vt = VT_I4;
				avarParams[3] = url;
				avarParams[3].vt = VT_BSTR;
				avarParams[2] = redirectedUrl;
				avarParams[2].vt = VT_BSTR;
				avarParams[1] = responseHeaders;
				avarParams[1].vt = VT_BSTR;
				avarParams[0] = requestHeaders;
				avarParams[0].vt = VT_BSTR;
				DISPPARAMS params = { avarParams, NULL, 7, 0 };
				hr = pConnection->Invoke(3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}

	HRESULT Fire_OnDataRecieved(LONG id, LONG containerId, BSTR url, BYTE* data, LONG cb, VARIANT_BOOL isComplete)
	{
		SAFEARRAYBOUND bounds = {cb, 0};

		VARIANT pBytes;
		VariantInit(&pBytes);
		pBytes.vt = VT_ARRAY | VT_UI1 | VT_BYREF;

		SAFEARRAY* psaByte = NULL; 
		BYTE *strNames;
		psaByte = SafeArrayCreate(VT_UI1, 1, &bounds);

		SafeArrayAccessData(psaByte, (void**)&strNames);

		for(long i = 0; i < cb; i++){
			strNames[i] = data[i];
		}

		SafeArrayUnaccessData(psaByte);
		pBytes.pparray = &psaByte;

		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[5];
				avarParams[4] = id;
				avarParams[4].vt = VT_I4;
				avarParams[3] = containerId;
				avarParams[3].vt = VT_I4;
				avarParams[2] = url;
				avarParams[2].vt = VT_BSTR;
				avarParams[1] = pBytes;
				avarParams[0] = isComplete;
				avarParams[0].vt = VT_BOOL;
				DISPPARAMS params = { avarParams, NULL, 5, 0 };
				hr = pConnection->Invoke(4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		SafeArrayDestroy(psaByte);
		return hr;
	}

	HRESULT Fire_OnCookieSent(LONG id, LONG containerId, BSTR url, BSTR cookies)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[4];
				avarParams[3] = id;
				avarParams[3].vt = VT_I4;
				avarParams[2] = containerId;
				avarParams[2].vt = VT_I4;
				avarParams[1] = url;
				avarParams[1].vt = VT_BSTR;
				avarParams[0] = cookies;
				avarParams[0].vt = VT_BSTR;
				DISPPARAMS params = { avarParams, NULL, 4, 0 };
				hr = pConnection->Invoke(5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}


	HRESULT Fire_OnCookieRecieved(LONG id, LONG containerId, BSTR url, BSTR cookies)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[4];
				avarParams[3] = id;
				avarParams[3].vt = VT_I4;
				avarParams[2] = containerId;
				avarParams[2].vt = VT_I4;
				avarParams[1] = url;
				avarParams[1].vt = VT_BSTR;
				avarParams[0] = cookies;
				avarParams[0].vt = VT_BSTR;
				DISPPARAMS params = { avarParams, NULL, 4, 0 };
				hr = pConnection->Invoke(6, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}

	HRESULT Fire_OnCacheLoaded(LONG id, LONG containerId, BSTR url, BSTR location)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[4];
				avarParams[3] = id;
				avarParams[3].vt = VT_I4;
				avarParams[2] = containerId;
				avarParams[2].vt = VT_I4;
				avarParams[1] = url;
				avarParams[1].vt = VT_BSTR;
				avarParams[0] = location;
				avarParams[0].vt = VT_BSTR;
				DISPPARAMS params = { avarParams, NULL, 4, 0 };
				hr = pConnection->Invoke(7, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}

	HRESULT Fire_OnMimeTypeAvailable(LONG id, LONG containerId, BSTR url, BSTR type)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[4];
				avarParams[3] = id;
				avarParams[3].vt = VT_I4;
				avarParams[2] = containerId;
				avarParams[2].vt = VT_I4;
				avarParams[1] = url;
				avarParams[1].vt = VT_BSTR;
				avarParams[0] = type;
				avarParams[0].vt = VT_BSTR;
				DISPPARAMS params = { avarParams, NULL, 4, 0 };
				hr = pConnection->Invoke(8, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}

	HRESULT Fire_OnP3PHeaderRecieved(LONG id, LONG containerId, BSTR url, BSTR p3PHeader)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[4];
				avarParams[3] = id;
				avarParams[3].vt = VT_I4;
				avarParams[2] = containerId;
				avarParams[2].vt = VT_I4;
				avarParams[1] = url;
				avarParams[1].vt = VT_BSTR;
				avarParams[0] = p3PHeader;
				avarParams[0].vt = VT_BSTR;
				DISPPARAMS params = { avarParams, NULL, 4, 0 };
				hr = pConnection->Invoke(9, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}

	HRESULT Fire_OnError(LONG id, LONG containerId, BSTR url, LONG result, LONG errorCode)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[5];
				avarParams[4] = id;
				avarParams[4].vt = VT_I4;
				avarParams[3] = containerId;
				avarParams[3].vt = VT_I4;
				avarParams[2] = url;
				avarParams[2].vt = VT_BSTR;
				avarParams[1] = result;
				avarParams[1].vt = VT_I4;
				avarParams[0] = errorCode;
				avarParams[0].vt = VT_I4;
				DISPPARAMS params = { avarParams, NULL, 5, 0 };
				hr = pConnection->Invoke(10, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}

	HRESULT Fire_ConfirmRequest(LONG id, LONG containerId, BSTR url, LONG cb, VARIANT_BOOL * itsMine)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[5];
				avarParams[4] = id;
				avarParams[4].vt = VT_I4;
				avarParams[3] = containerId;
				avarParams[3].vt = VT_I4;
				avarParams[2] = url;
				avarParams[2].vt = VT_BSTR;
				avarParams[1] = cb;
				avarParams[1].vt = VT_I4;
				avarParams[0] = itsMine;
				avarParams[0].vt = VT_BOOL|VT_BYREF;
				DISPPARAMS params = { avarParams, NULL, 5, 0 };
				hr = pConnection->Invoke(11, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}	

	HRESULT Fire_OnProgress(LONG id, LONG containerId, BSTR url, LONG grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[6];
				avarParams[5] = id;
				avarParams[5].vt = VT_I4;
				avarParams[4] = containerId;
				avarParams[4].vt = VT_I4;
				avarParams[3] = url;
				avarParams[3].vt = VT_BSTR;
				avarParams[2] = grfBSCF;
				avarParams[2].vt = VT_I4;
				avarParams[1] = ulProgress;
				avarParams[1].vt = VT_UI4;
				avarParams[0] = ulProgressMax;
				avarParams[0].vt = VT_UI4;
				DISPPARAMS params = { avarParams, NULL, 6, 0 };
				hr = pConnection->Invoke(12, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}

	HRESULT Fire_GetIServiceProviderOnStart(LONG id, LONG containerId, BSTR url, LONG ptr)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[4];
				avarParams[3] = id;
				avarParams[3].vt = VT_I4;
				avarParams[2] = containerId;
				avarParams[2].vt = VT_I4;
				avarParams[1] = url;
				avarParams[1].vt = VT_BSTR;
				avarParams[0] = ptr;
				avarParams[0].vt = VT_I4;
				DISPPARAMS params = { avarParams, NULL, 4, 0 };
				hr = pConnection->Invoke(13, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, NULL, NULL, NULL);
			}
		}
		return hr;
	}
};